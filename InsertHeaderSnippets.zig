// Based on `ConfigHeader` in the standard library.
// Copyright (c) Zig contributors

const std = @import("std");
const mem = std.mem;
const InsertHeaderSnippets = @This();
const Step = std.Build.Step;
const Allocator = mem.Allocator;

step: Step,
output_file: std.Build.GeneratedFile,
source_file: std.Build.LazyPath,
snippets: []const Snippet,
max_bytes: usize,

pub const base_id: Step.Id = .custom;

pub const Snippet = struct {
    file: std.Build.LazyPath,
    line_pattern: []const u8,
};

pub const Options = struct {
    source_file: std.Build.LazyPath,
    snippets: []const Snippet,
    max_bytes: usize = 2 * 1024 * 1024,
    first_ret_addr: ?usize = null,
};

pub fn create(owner: *std.Build, options: Options) *InsertHeaderSnippets {
    const arena = owner.allocator;

    const ihs = arena.create(InsertHeaderSnippets) catch @panic("OOM");

    const name = owner.fmt(
        "insert snippet in header {s}",
        .{options.source_file.getDisplayName()},
    );

    const snippets = arena.alloc(Snippet, options.snippets.len) catch @panic("OOM");
    for (options.snippets, snippets) |source, *target| {
        target.* = .{
            .file = source.file,
            .line_pattern = owner.dupe(source.line_pattern),
        };
    }

    ihs.* = .{
        .step = Step.init(.{
            .id = base_id,
            .name = name,
            .owner = owner,
            .makeFn = make,
            .first_ret_addr = options.first_ret_addr orelse @returnAddress(),
        }),
        .output_file = .{ .step = &ihs.step },
        .source_file = options.source_file,
        .snippets = snippets,
        .max_bytes = options.max_bytes,
    };

    options.source_file.addStepDependencies(&ihs.step);

    for (snippets) |snippet| {
        snippet.file.addStepDependencies(&ihs.step);
    }

    return ihs;
}

pub fn getOutput(ihs: *InsertHeaderSnippets) std.Build.LazyPath {
    return .{ .generated = .{ .file = &ihs.output_file } };
}

fn make(step: *Step, options: Step.MakeOptions) !void {
    _ = options;
    const b = step.owner;
    const ihs: *InsertHeaderSnippets = @fieldParentPtr("step", step);

    const arena = b.allocator;

    var man = b.graph.cache.obtain();
    defer man.deinit();

    // Random bytes to make InsertHeaderSnippets unique. Refresh this with new
    // random bytes when InsertHeaderSnippets implementation is modified in a
    // non-backwards-compatible way.
    man.hash.add(@as(u32, 0x5e09c76e));

    var output = std.ArrayList(u8).init(arena);
    defer output.deinit();

    try output.appendSlice(
        \\/* This file was generated by InsertHeaderSnippets using the Zig Build System. */
        \\
    );

    const source_path = ihs.source_file.getPath2(b, step);
    const source_text = std.fs.cwd().readFileAlloc(arena, source_path, ihs.max_bytes) catch |err| {
        return step.fail("unable to read header file '{s}': {s}", .{
            source_path, @errorName(err),
        });
    };

    const snippet_texts = arena.alloc([]const u8, ihs.snippets.len) catch @panic("OOM");
    for (ihs.snippets, snippet_texts) |snippet, *text| {
        const snippet_path = snippet.file.getPath2(b, step);
        text.* = std.fs.cwd().readFileAlloc(arena, snippet_path, ihs.max_bytes) catch |err| {
            return step.fail("unable to read snippet file '{s}': {s}", .{
                snippet_path, @errorName(err),
            });
        };
        if (text.*[text.len - 1] != '\n') {
            return step.fail("snippet file '{s}' does not end with a newline", .{snippet_path});
        }
    }

    const matches = arena.alloc(bool, ihs.snippets.len) catch @panic("OOM");
    for (matches) |*matched| matched.* = false;

    var pos: usize = 0;
    while (pos < source_text.len) {
        const pos_newline = mem.indexOfScalarPos(u8, source_text, pos, '\n') orelse source_text.len;
        try output.appendSlice(source_text[pos..@min(pos_newline +| 1, source_text.len)]);
        for (ihs.snippets, snippet_texts, matches) |snippet, text, *matched| {
            if (mem.indexOfPos(u8, source_text[0..pos_newline], pos, snippet.line_pattern)) |_| {
                if (matched.*) {
                    return step.fail(
                        "header '{s}' contains multiple matches of the pattern '{s}'",
                        .{ source_path, snippet.line_pattern },
                    );
                }
                matched.* = true;
                if (pos_newline == source_text.len) {
                    return step.fail(
                        "header '{s}' does not contain a newline after matched pattern '{s}'",
                        .{ source_path, snippet.line_pattern },
                    );
                }
                try output.appendSlice(text);
            }
        }
        pos = pos_newline +| 1;
    }

    if (mem.indexOfScalar(bool, matches, false)) |i| {
        return step.fail(
            "header '{s}' does not contain pattern '{s}'",
            .{ source_path, ihs.snippets[i].line_pattern },
        );
    }

    man.hash.addBytes(output.items);

    if (try step.cacheHitAndWatch(&man)) {
        const digest = man.final();
        ihs.output_file.path = try b.cache_root.join(arena, &.{
            "o", &digest, "config.h",
        });
        return;
    }

    const digest = man.final();

    const sub_path = b.pathJoin(&.{ "o", &digest, "config.h" });
    const sub_path_dirname = std.fs.path.dirname(sub_path).?;

    b.cache_root.handle.makePath(sub_path_dirname) catch |err| {
        return step.fail("unable to make path '{}{s}': {s}", .{
            b.cache_root, sub_path_dirname, @errorName(err),
        });
    };

    b.cache_root.handle.writeFile(.{ .sub_path = sub_path, .data = output.items }) catch |err| {
        return step.fail("unable to write file '{}{s}': {s}", .{
            b.cache_root, sub_path, @errorName(err),
        });
    };

    ihs.output_file.path = try b.cache_root.join(arena, &.{sub_path});
    try step.writeManifestAndWatch(&man);
}
