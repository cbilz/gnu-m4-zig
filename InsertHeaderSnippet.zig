// Based on `ConfigHeader` in the standard library.
// Copyright (c) Zig contributors

const std = @import("std");
const InsertHeaderSnippet = @This();
const Step = std.Build.Step;
const Allocator = std.mem.Allocator;

step: Step,
output_file: std.Build.GeneratedFile,
source_file: std.Build.LazyPath,
snippet_file: std.Build.LazyPath,
line_pattern: []const u8,
max_bytes: usize,

pub const base_id: Step.Id = .custom;

pub const Options = struct {
    source_file: std.Build.LazyPath,
    snippet_file: std.Build.LazyPath,
    line_pattern: []const u8,
    max_bytes: usize = 2 * 1024 * 1024,
    first_ret_addr: ?usize = null,
};

pub fn create(owner: *std.Build, options: Options) *InsertHeaderSnippet {
    const ihs = owner.allocator.create(InsertHeaderSnippet) catch @panic("OOM");

    const name = owner.fmt(
        "insert snippet {s} in header {s}",
        .{ options.snippet_file.getDisplayName(), options.source_file.getDisplayName() },
    );

    ihs.* = .{
        .step = Step.init(.{
            .id = base_id,
            .name = name,
            .owner = owner,
            .makeFn = make,
            .first_ret_addr = options.first_ret_addr orelse @returnAddress(),
        }),
        .source_file = options.source_file,
        .snippet_file = options.snippet_file,
        .line_pattern = owner.dupePath(options.line_pattern),
        .max_bytes = options.max_bytes,
        .output_file = .{ .step = &ihs.step },
    };

    options.source_file.addStepDependencies(&ihs.step);
    options.snippet_file.addStepDependencies(&ihs.step);

    return ihs;
}

pub fn getOutput(ihs: *InsertHeaderSnippet) std.Build.LazyPath {
    return .{ .generated = .{ .file = &ihs.output_file } };
}

fn make(step: *Step, options: Step.MakeOptions) !void {
    _ = options;
    const b = step.owner;
    const ihs: *InsertHeaderSnippet = @fieldParentPtr("step", step);

    const arena = b.allocator;

    var man = b.graph.cache.obtain();
    defer man.deinit();

    // Random bytes to make InsertHeaderSnippet unique. Refresh this with new
    // random bytes when InsertHeaderSnippet implementation is modified in a
    // non-backwards-compatible way.
    man.hash.add(@as(u32, 0x5e09c76e));
    man.hash.addBytes(ihs.line_pattern);

    var output = std.ArrayList(u8).init(arena);
    defer output.deinit();

    try output.appendSlice(
        \\/* This file was generated by InsertHeaderSnippet using the Zig Build System. */
        \\
    );

    const source_path = ihs.source_file.getPath2(b, step);
    const source = std.fs.cwd().readFileAlloc(arena, source_path, ihs.max_bytes) catch |err| {
        return step.fail("unable to read header file '{s}': {s}", .{
            source_path, @errorName(err),
        });
    };
    const snippet_path = ihs.snippet_file.getPath2(b, step);
    const snippet = std.fs.cwd().readFileAlloc(arena, snippet_path, ihs.max_bytes) catch |err| {
        return step.fail("unable to read snippet file '{s}': {s}", .{
            snippet_path, @errorName(err),
        });
    };

    const pos_pattern = std.mem.indexOf(u8, source, ihs.line_pattern) orelse {
        return step.fail(
            "header '{s}' does not contain pattern '{s}'",
            .{ source_path, ihs.line_pattern },
        );
    };
    const pos_newline = std.mem.indexOfScalarPos(
        u8,
        source,
        pos_pattern + ihs.line_pattern.len,
        '\n',
    ) orelse {
        return step.fail(
            "header '{s}' does not contain a newline after matched pattern '{s}'",
            .{ source_path, ihs.line_pattern },
        );
    };

    if (snippet[snippet.len - 1] != '\n') {
        return step.fail("snippet file '{s}' does not end with a newline", .{snippet_path});
    }

    try output.appendSlice(source[0 .. pos_newline + 1]);
    try output.appendSlice(snippet);
    try output.appendSlice(source[pos_newline + 1 ..]);

    man.hash.addBytes(output.items);

    if (try step.cacheHitAndWatch(&man)) {
        const digest = man.final();
        ihs.output_file.path = try b.cache_root.join(arena, &.{
            "o", &digest, "config.h",
        });
        return;
    }

    const digest = man.final();

    const sub_path = b.pathJoin(&.{ "o", &digest, "config.h" });
    const sub_path_dirname = std.fs.path.dirname(sub_path).?;

    b.cache_root.handle.makePath(sub_path_dirname) catch |err| {
        return step.fail("unable to make path '{}{s}': {s}", .{
            b.cache_root, sub_path_dirname, @errorName(err),
        });
    };

    b.cache_root.handle.writeFile(.{ .sub_path = sub_path, .data = output.items }) catch |err| {
        return step.fail("unable to write file '{}{s}': {s}", .{
            b.cache_root, sub_path, @errorName(err),
        });
    };

    ihs.output_file.path = try b.cache_root.join(arena, &.{sub_path});
    try step.writeManifestAndWatch(&man);
}
